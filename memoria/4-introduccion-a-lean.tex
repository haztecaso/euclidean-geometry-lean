\section{Introducci\'{o}n a Lean}

\subsection{Teoría de tipos informal}

Lo primero que se necesita en matemáticas para poder formalizar afirmaciones es
un lenguaje formal con el cual expresarlas. Normalmente se utiliza la lógica de
primer orden con los axiomas de la teoría de conjuntos.
\textit{Lean}\footnote{En este trabajo hemos utilizado a la versión 3 del
	lenguaje \textit{Lean}. La versión más actual del lenguaje es la 4, que
	incorpora muchos cambios. Gran parte de la comunidad sin embargo continúa
	utilizando la versión 3, mientras que se terminan de migrar los resultados ya
	formalizados a la nueva versión.}, sin embargo, utiliza un sistema deductivo
diferente, el de la teoría de tipos \textit{Cálculo de construcciones
	inductivas} (\textit{Calculus of Inductive Constructions} en inglés).

En lógica se tiene la aserción fundamental \textit{que de una serie de fórmulas
	se pueda derivar una demostración de una proposición}. Es decir, cada
proposición $P$ da lugar a la aserción correspondiente \textit{P tiene una
	prueba} (a veces dejamos implícito el contexto de fórmulas desde las que se
deriva la demostración). Mediante ciertas reglas de transformación, y a veces
una serie de axiomas, se pueden construir nuevas pruebas. Por ejemplo, dada la
regla de inferencia \textit{de $A$ se deduce $A$ o $B$} y la aserción \textit{A
	tiene una prueba}, se obtiene la aserción \textit{A o B tiene una prueba}.

En una teoría de tipos la aserción fundamental es \textit{que de una serie de
	términos con sus tipos se pueda derivar que un término tiene un
	tipo}\footnote{La referencia que hemos seguido en esta introducción a la teoría
	de tipos es el primer capítulo del libro \textit{Homotopy Type
		Theory}~\cite{HomotopyTypeTheory}.}. Dados un término $a$ y un tipo $A$, si
\textit{$a$ tiene tipo $A$} escribimos $a:A$. Esta es misma notación es la
utilizada en \textit{Lean}, en el que por ejemplo podemos expresar la aserción
\textit{3 es un número natural} con el código \lstinline{3 : ℕ}.

Es importante no confundir esta notación con la de una relación interna a
nuestro lenguaje. Mientras que en teoría de conjuntos utilizamos la relación de
pertenencia $\in$ para expresar que un elemento primitivo (un conjunto) está
contenido en otro, en las teorías de tipos no podemos considerar los términos o
los tipos por separado. La noción fundamental es la pertenencia de tipos y cada
término tiene que estar siempre acompañado por su tipo. En las teorías de tipos
además existen otras aserciones, como la de igualdad entre términos de un mismo
tipo. Dados $a:A$ y $b:A$, se tiene la aserción \textit{$a$ y $b$ son dos
	términos de tipo A iguales por definición}, y escribimos $a\equiv b : A$
\footnote{En \textit{Lean} existe más de un tipo de igualdad entre términos. La
	mencionada aquí es la llamada igualdad \textit{sintáctica}, que se representa
	con el símbolo \lstinline{=}. Tamibién existen las igualdades
	\textit{definicionales} y \textit{proposicionales}.}.

Las teorías de tipos también pueden utilizarse para expresar afirmaciones y
demostraciones matemáticas. Las afirmaciones se codifican mediante los tipos y
las demostraciones mediante construcciones de términos de un tipo dado. Es
decir, se puede interpretar la aserción $a : A$ como \textit{$a$ es una
	demostración de $A$}. Esta interpretación da lugar a una analogía entre la
lógica proposicional y una teoría de tipos, llamada correspondencia de
Curry-Howard. Sin entrar en detalles, a cada proposición lógica se le puede
asignar un tipo, y a cada demostración de un enunciado un término del tipo
correspondiente al enunciado.

Existen distintas elecciones de reglas de transformación que considerar en
teoría de tipos, que dan lugares a distintas versiones de la teoría de tipos.
Lean implementa una una versión de la teoría de tipos dependiente conocida como
el \textit{Calculus of Constructions}.

En las explicaciones que siguen la principal referencia a la que hemos recurrido
es el manual oficial \textit{Theorem proving in Lean}~\cite{avigadLeanTheoremProver}.

\subsection{Funciones en el $\lambda$-c\'{a}lculo}

La base de muchas teorías de tipos es el lambda cálculo tipado. El lambda
cálculo es un modelo universal de computación introducido por \textit{Alonzo
	Church} en los años treinta. Sin entrar en su formalización, en el lambda
cálculo se consideran dos operaciones fundamentales para tratar con funciones,
la abstracción y la evaluación.

\begin{itemize}[topsep=0pt]
	\item \textbf{Abstracción}. Es el mecanismo de definición de funciones mediante
	      la introducción de parámetros. Dado un término \lstinline{x + 1 : ℕ},
	      mediante la sintaxis \lstinline{λ x : ℕ, (x + 1 : ℕ)} se convierte la
	      variable libre \lstinline{x} en una variable ligada por la abstracción, a la
	      que llamamos parámetro de la función.

	      Es importante recordar que cada término tiene que ir acompañado del tipo al
	      que pertenece. En esta expresión estamos indicando que tanto el parámetro
	      \lstinline{x} como el resultado de la función, \lstinline{x+1}, son de tipo
	      \lstinline{ℕ}. Es decir, tenemos una función que dado un número natural
	      devuelve otro número natural. Esto también puede escribirse como
	      \lstinline{(λ x, x + 1) : ℕ → ℕ}.

	      Lean además incluye notación para definir funciones que devuelven otras
	      funciones, lo cual es muy útil para tratar funciones que reciben más de un
	      parámetro\footnote{La transformación de funciones de varios
		      parámetros en funciones de orden superior se denomina
		      \textit{currificación}.}. Las siguientes líneas de código
	      definen expresiones equivalentes
	      \begin{lstlisting}
λ a : α, λ b : β, a
λ (a : α) (b : β), a
\end{lstlisting}
	      que representan el mismo término, de tipo \lstinline{α → β → α}.

	\item \textbf{Evaluación}. Consiste en aplicar funciones, pasándoles los
	      valores de los argumentos que evaluar. Por ejemplo la expresión
	      \lstinline{(λ x : ℕ, (x + 1) : ℕ) (1 : ℕ)} indica que estamos evaluando la
	      función \lstinline{(λ x, x + 1) : ℕ → ℕ} con el parámetro \lstinline{x}
	      sustituido por el término \lstinline{1 : ℕ} (para que la sustitución pueda
	      realizarse los tipos deben coincidir). Mediante un proceso de
	      reducción se obtiene el término \lstinline{2 : ℕ}.

\end{itemize}

La teoría de tipos que implementa \textit{Lean}, el \textit{Cálculo de las
	construcciones inductivas}, introduce una serie de reglas y formas de construir
tipos adicionales, como los \textit{tipos inductivos} o los \textit{tipos
	dependientes}, útiles para formalizar definiciones inductivas y cuantificadores
lógicos.

Como se ve en los ejemplos, el código fuente de Lean se pueden incluir
caracteres unicode, como \lstinline{λ}, \lstinline{→} o \lstinline{ℕ}.
En el apéndice~\ref{sec:entorno} explicamos cómo introducir estos caracteres
en el entorno de desarrollo.

Que cada término sea siempre considerado junto a su tipo no significa que sea
siempre necesario explicitar dicho tipo. Lean tiene un mecanismo llamado
\textit{inferencia de tipos} que le permite deducir automáticamente el tipo de
un término cuando no ha sido explicitado pero el contexto aporta información
suficiente.
Por ejemplo, cuando definimos la función \lstinline{λ x : ℕ, (x + 1 : ℕ)} no es
necesario incluir la segunda anotación de tipo. Dada la expresión
\lstinline{x + 1} y sabiendo por contexto que \lstinline{x : ℕ} el sistema de
inferencia de tipos deduce que la suma de dos números naturales también es un
número natural, por lo que se infiere el tipo \lstinline{ℕ}.

\subsection{Introducci\'{o}n de t\'{e}rminos}

En lean existen distintas formas de introducir nuevos términos en el entorno
actual.

\subsubsection*{Constantes}%

Mediante los comandos \lstinline{constant} y \lstinline{constants} se
pueden introducir términos en el entorno, postulando su existencia. Este comando
equivale por tanto a considerar nuevos axiomas sobre la existencia de los
términos que introduce.
\begin{lstlisting}
constant a : ℕ
constants (b : ℤ) (c : ℂ)
\end{lstlisting}


\subsubsection*{Definiciones}%

También se pueden definir nuevos términos introduciendo nombres, en este caso
sin introducir nuevos axiomas, mediante el comando \lstinline{def}. Como estamos
definiendo un símbolo, es necesario proporcionar el tipo y término que queremos
asignar al símbolo:

\begin{lstlisting}
def succ : ℕ → ℕ := λ n, n + 1
def succ' (n : ℕ) : ℕ := n + 1 -- Otra forma de definir succ
\end{lstlisting}

Para introducir parámetros de funciones se puede omitir la notación
\lstinline{λ}, incluyendo las variables parametrizadas antes de los dos puntos
que anotan el tipo de la definición.

Esta notación de introducción de parámetros es muy útil y simple, pero puede
resultar demasiado explícita. Veamos por ejemplo cómo se puede definir la
función identidad, que dado un término de un tipo devuelve el mismo término.
Si queremos que la identidad definida sea sea general y se le puedan aplicar términos
de cualquier tipo necesitaremos introducir el tipo del término como un parámetro
adicional.

\begin{lstlisting}
def id1 (α : Type*) (e : α) := e
\end{lstlisting}

El problema de esta definición es que cada vez que se quiera utilizar será
necesario proporcionarle como primer argumento el tipo del término que se le
quiere pasar, por ejemplo \lstinline{id1 ℕ 0}.
Pero la función identidad que queremos considerar recibe un solo argumento.
Como a cada término acompaña siempre su tipo, dado el término \lstinline{e : α},
el sistema de inferencia de tipos de Lean es capaz de deducir automáticamente el
tipo \lstinline{α}. Solo falta indicar en la definición cuál es el parámetro
cuya identificación queremos delegar al sistema de inferencia de tipos.

\begin{lstlisting}
def id2 {α : Type*} (e : α) := e
\end{lstlisting}

Así los parámetros indicados entre llaves, llamados \textit{parámetros
	implícitos}, serán deducidos automaticamente.

\subsubsection*{Variables}%

Otra forma de indicar parámetros en una definición es mediante el uso del
comando \lstinline{variable} (o su variante \lstinline{variables}) que introduce
en el entorno el símbolo indicado, pero en lugar de fijar su existencia como
\lstinline{constant} el símbolo introducido está \guillemotleft cuantificado
univeralmente\guillemotright. Las siguientes líneas son equivalentes a las del
ejemplo anterior:

\begin{lstlisting}
variable {α : Type*}
def id3 (e : α) := e
\end{lstlisting}

\subsection{Proposiciones}

En \textit{Lean} se tiene el tipo \lstinline{Prop} para expresar las
proposiciones mediante la analogía de \textit{proposiciones como tipos} dada por
la correspondencia de Curry-Howard, que relaciona \textit{tipos} con
\textit{proposiciones}. Esta relación recibe el nombre de \textit{proposiciones
	como tipos}. Los términos de tipo \lstinline{P : Prop}, que representan las
proposiciones, son a su vez tipos y por tanto pueden tener términos.

La correspondencia de Curry-Howard afirma que estas las $\lambda$-funciones de
se comportan de la misma forma que la implicación en lógica.
Por tanto en \textit{Lean} usamos el símbolo \lstinline{→} para referirnos tanto a
funciones como a implicaciones lógicas. Dadas dos
proposiciones \lstinline{p q : Prop} podemos construir la proposición
\lstinline{p → q : Prop}, que se interpreta como \lstinline{p} \textit{implica}
\lstinline{q}.


También tenemos a nuestra disposición los demás conectores lógicos usuales,
definidos en la librería estándar de \textit{Lean}. Los símbolos que
utilizaremos para estos conectores son \lstinline{∧}, \lstinline{∨},
\lstinline{¬}, \lstinline{≠} y \lstinline{↔}. Además, los tipos dependientes del
\textit{Cálculo de construcciones inductivas} permiten definir los
cuantificadores existencial y universal, expresados en \textit{Lean} mediante
los símbolos \lstinline{∃} y \lstinline{∀}.

\subsection{Demostraciones}

Mintras que en la correspondencia de \textit{Curry-Howard} las proposiciones se
corresponden con los tipos, la demostración de una proposición se corresponde
con el hecho de que el tipo de la proposición tenga un término. Es decir, dada
una proposición \lstinline{P : Prop}, un término \lstinline{p : P} es una
demostración de dicha proposición.

Si un tipo tiene un término se dice que está \textit{habitado}. Por tanto decir
que un término de tipo \lstinline{Prop} está habitado equivale a decir que la
proposición correspondiente tiene una demostración. Esta equivalencia entre
términos y demostraciones es llamada \textit{demostraciones como términos}.

Sin embargo desarrollar demostraciones construyendo directamente estos términos
suele resultar muy complicado y alejado del trabajo deductivo matemático usual.
Como muchos otros asistentes de demostración \textit{Lean} tiene definidos una
serie de comandos, llamados \textit{tácticas}, que permiten describir en un
nivel de abstracción más alto cómo se construyen estas demostraciones.

En matemáticas solemos recurrir a frases informales como \guillemotleft
podemos demostrar la siguiente aplicación aplicando el lema anterior,
deshaciendo las definiciones y simplificando la expresión resultante
\guillemotright, que proporcionan una \textit{receta} de construcción de
demostración. De forma análoga las tácticas son instrucciones que indican al
sistema de tipos de \textit{Lean} cómo construir el término de una demostración.

En \textit{Lean} se pueden desarrollar demostraciones utilizando los denominados
\textit{modo de términos} y \textit{modo táctico}, que además pueden ser
entremezclados. En este trabajo nos hemos limitado a utilizar el  \textit{modo
	táctico}, ya resulta más intuitivo, fácil de usar y cercano a la forma de
demostrar usual en matemáticas.

Para enunciar un resultado y demostrarlo se utiliza el comando \lstinline{lemma}
o \lstinline{theorem}, con la misma sintaxis de \lstinline{def}:

\begin{lstlisting}
lemma ej (P Q : Prop) (h1 : P ∨ Q) (h2 : P → Q) : Q :=
  or.elim h1 h2 (λ hQ : Q, hQ)
\end{lstlisting}

En este ejemplo se ha utilizado el modo de términos para desarrollar la
demostración. La misma demostración se puede realizar en el modo táctico, al que
podemos entrar usando las instrucciones \lstinline{begin} y \lstinline{end}:

\begin{lstlisting}
lemma ej (P Q : Prop) (h1 : P ∨ Q) (h2 : P → Q) : Q :=
begin
  cases h1,
  sorry
end
\end{lstlisting}

Una demostración en modo táctico consiste en la aplicación sucesiva de tácticas,
que van modificando el \textit{estado táctico}, que está formado por una serie
de \textit{hipótesis} y una \textit{meta}. Antes de la aplicación de la primera
táctica el estado táctico está formado por las hipótesis del lema o teorema y la
meta se corresponde con el resultado a demostrar. Modificando las hipótesis y la
meta sucesivamente podremos \textit{cerrar la meta}, es decir completar la
demostración.

En el ejemplo anterior se ha usado la táctica \lstinline{sorry}, que cierra
cualquier meta y se usa para indicar que todavía no hemos terminado la
demostración. Un ejemplo de demostración completa de este ejemplo en modo
táctico es:

\begin{lstlisting}
lemma ej (P Q : Prop) (h1 : P ∨ Q) (h2 : P → Q) : Q :=
begin
  cases h1,
  { apply h2, exact h1 },
  { exact h1 },
end
\end{lstlisting}

\subsection{Mathlib}

Uno de los mayores puntos fuertes del ecosistema de \textit{Lean} es la librería
\textit{mathlib}, donde se encuentra una amplia colección de resultados
matemáticos formalizados. Además la librería incluye definiciones de tácticas
que implementan esquemas de demostración particulares de distintas ramas de las
matemáticas.

Debido a la naturaleza del lenguaje y a las particularidades de la teoría de
tipos que se utiliza, muchas teorías matemáticas están implementadas de forma
distinta a la de muchos libros de texto o que se enseña en cursos introductorios
en el grado de matemáticas. Por ejemplo las construcciones en topología se
basan en los \textit{filtros}, en lugar de en los \textit{entornos} y
\textit{bases de entornos}.

\todo{Explicar cómo utilizar la web para encontrar cosas.}



















