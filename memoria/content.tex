
\addcontentsline{toc}{section}{Introducción}
\section*{Introducción}

Los asistentes de demostración nos permiten formalizar definiciones, enunciados
de proposiciones y teoremas, demostraciones, y verficar estas definiciones.
Formalizar matemáticas consiste en digitalizar enunciados y resultados
escribiéndolos en un lenguaje de programación que garantiza, mediante una
correspondencia entre una teoríá de tipos y la lógica, la validez de cada paso.

Algunos beneficios de formalizar enunciados y resultados matemáticos mediante un
asistente de demostración son:

\newpage

\section{Matemáticas formales}

La formalización matemática es el proceso de representar enunciados y
demostraciones matemáticas utilizando un lenguaje formal y un conjunto de reglas
lógicas bien definidas. En este contexto, se establece un conjunto de
proposiciones fundamentales, conocidas como axiomas, que se aceptan sin requerir
justificación. Estos axiomas se manipulan y transforman mediante la aplicación
sistemática de las reglas lógicas para derivar nuevas proposiciones matemáticas.
El proceso de aplicar secuencialmente estas reglas lógicas para obtener una
conclusión a partir de proposiciones más básicas es conocido como demostración.


En la historia de las matemáticas los \textit{Elementos} de \textit{Euclides},
tratado matemático compuesto de trece libros escrito en el siglo III a.C., son
el ejemplo más antiguo de proyecto de formalización matemática. En la obra se
trata rigurosamente una extensa variedad de temas, como la geometría plana y
espacial o la teoría de números. Euclides es el primer autor en presentar los
conocimientos matemáticos siguiendo un método formal. En los tratados se
presentan los argumentos a partir de una serie de postulados, definiciones y
nociones comunes a partir de los cuales se demuestran proposiciones y teoremas
mediante razonamientos deductivos.

La obra de Euclides ha tenido una profunda influencia en las matemáticas, la
lógica y la filosofía. Los \textit{Elementos} se mantuvieron como la principal
referencia en geometría durante casi dos milenios. Las pruebas rigurosas,
apoyadas en el razonamiento lógico y la estructura del tratado establecieron un
estándar para la argumentación y la exposición matemática que todavía se
conserva en la actualidad.

A lo largo de la historia, se ha evidenciado que los \textit{Elementos} de
\textit{Euclides} no se ciñen estrictamente al método axiomático. En el tratado
se encuentran razonamientos sustentados en intuiciones geométricas y
construcciones con regla y compás, en lugar de en deducciones estrictamente
lógicas derivadas de los postulados.

Durante siglos, matemáticos y filósofos han examinado y escrutado la obra de
Euclides, identificando errores y omisiones y planteando cuestiones sobre la
relación entre los postulados. El quinto postulado de Euclides, también conocido
como postulado de las paralelas, ha sido sometido a un análisis riguroso. Este
postulado afirma que, dada una línea recta y un punto fuera de ella, existe
únicamente una línea recta paralela a la línea dada que pasa por el punto en
cuestión. Por siglos, numerosos matemáticos, intuyendo la innecesariedad del
postulado, intentaron demostrarlo a partir de los otros cuatro, pero sin éxito.
El problema fue resuelto en el siglo XIX con la concepción de nuevas geometrías,
como la hiperbólica y la elíptica, en las cuales el postulado de las paralelas
no se verifica. Quedó así demostrada la independencia del quinto postulado
respecto a los primeros cuatro, y por tanto su necesidad para la construcción de
la geometría euclídea.

Durante el siglo XIX se dieron avances trascendentales en el desarrollo de las
matemáticas y la lógica formales. Ejemplos notables son la
formulación del álgebra de Boole, la lógica de predicados propuesta por
\textit{Gottlob Frege} o el desarrollo de la \textit{aritmética de Peano}.
En este contexto el matemático alemán \textit{David Hilbert} publicó su obra
\textit{Grundlagen der Geometrie} (Fundamentos de Geometría), en la cual se
lleva a cabo una revisión exhaustiva de los \textit{Elementos}, planteando una
nueva axiomatización para formalizar correctamente los resultados de la
geometría euclídea, eliminando por completo el recurso a la intuición y
razonamientos geométricos en la presentación de los resultados.


\redactar{Explicar que este es el punto de partida en el que enmarcar este
	trabajo. A partir de aqui se va a explicar  qué aporta la formalización
	matemática asistida por computadores y en que sentido es un paso más.}

\section{Formalización asistida por computadores}

Introducción a la formalización en Lean. Demostración asistida por computadores. ¿Pa que?
\begin{itemize}
	\item Comprobación mecanizada de demostraciones.
	\item Digitalizar resultados y crear base de datos.
	      FormalAbstracts
	\item Investigación en técnicas de demostración automática
\end{itemize}

\section{Lean}

En esta sección se introducen los elementos básicos del lenguaje para

\subsection{Cómo enunciar proposiciones con teoría de tipos}

Estado táctico: hipótesis y metas.

\begin{description}
	\item[Tipos y conjuntos] Analogías y diferencias
	\item[hipótesis] Los resultados pueden depender de unas hipótesis,
		enunciadas antes de los \lstinline{:}.
	\item[El tipo Prop]
	\item[Implicación y funciones]
	\item[Doble implicación]
	\item[and y or como tipos inductivos]
	\item[Términos true y false]
	\item[La negación]
\end{description}

% \subsection{Tácticas básicas}

% \begin{description}[font=\sffamily\bfseries, leftmargin=1.5cm, style=nextline]
% 	\item[refl] Sirve para demostrar metas de la forma \lstinline{A = A}. Por
% 		ejemplo, podemos demostrar que todo punto es igual a si mismo:

% 		\begin{lstlisting}
% lemma point_refl (A : Point) : A = A :=
% begin
%   refl
% end
%         \end{lstlisting}
% 	\item[rw] Para reescribir
% 	\item[exact] Si la meta es  \lstinline{⊢ X} y \lstinline{x} es un término de
% 		tipo \lstinline{X} se puede usar la táctica \lstinline{exact x} para
% 		cerrar la meta.
% 	\item[apply] Demostrar hacia atrás
% 	\item[intro] Introducir hipótesis
% 		\begin{lstlisting}
% lemma equal_comm (A B : Point) : A = B → B = A :=
% begin
%   intro h,
%   sorry
% end
%         \end{lstlisting}


% 	\item[split] Dividir la meta
% 	\item[left, right] Modificar la meta
% 	\item[exfalso] Cambia la meta a false
% 	\item[by_cases] Para dividir la demostración en casos.
% 	\item[have] Demostrar resultados intermedios
% 	\item[cases] Varios usos. Descomponer and, or o exists.

% \end{description}

% \subsection{Tácticas de nivel alto}

% \begin{description}
% 	\item[simp] Para demostrar igualdades
% \end{description}

% \newpage
\section{Introducción a Lean}
\section{Teoría de tipos informal}

Lo primero que se necesita en matemáticas para poder formalizar afirmaciones es
un lenguaje formal con el cual expresarlas. Normalmente se utiliza la lógica de
primer orden, en el contexto de la teoría de conjuntos. Lean, sin embargo,
utiliza un sistema deductivo diferente, el de la teoría de tipos.

En lógica de primer se tiene una aserción fundamental, \textit{que una
	proposición dada tenga una prueba}. Es decir, cada proposición $P$ da lugar a la
aserción correspondiente \textit{P tiene una prueba}. Mediante ciertas reglas de
transformación, y a veces una serie de axiomas, se pueden construir nuevas
pruebas. Por ejemplo, dada la regla de inferencia \textit{de $A$ se deduce $A$ o
	$B$} y la aserción \textit{A tiene una prueba}, se obtiene la aserción \textit{A
	o B tiene una prueba}.

En teoría de tipos la aserción fundamental es \textit{que un término tenga un
	tipo}. Dados un término $a$ y un tipo $A$, si \textit{$a$ tiene tipo $A$}
escribimos $a:A$. Esta es misma notación es la utilizada por Lean, en el que por
ejemplo podemos expresar la aserción \textit{3 es un número natural} con el
código \lstinline{3 : ℕ}.

Es importante no confundir esta notación con la de una
relación interna a nuestro lenguaje. Mientras que en teoría de conjuntos
utilizamos la relación de pertenencia $\in$ para expresar que un elemento
primitivo (un conjunto) está contenido en otro, en teoría de tipos no podemos
considerar los términos o los tipos por separado. La noción fundamental es la
pertenencia de tipos y cada término tiene que estar siempre acompañado por su
tipo. En teoría de tipos además existen otras aserciones, como la de igualdad
entre términos de un mismo tipo. Dados $a:A$ y $b:A$, se tiene la aserción
\textit{$a$ y $b$ son dos términos de tipo A iguales por definición}, y
escribimos $a\equiv b : A$.

La teoría de tipos también puede utilizarse para expresar afirmaciones y
demostraciones matemáticas. Las afirmaciones se codifican mediante los tipos y
las demostraciones mediante construcciones de términos de un tipo dado. Es
decir, se puede interpretar la aserción $a : A$ como \textit{$a$ es una
	demostración de $A$}. Esta interpretación da lugar a una analogía entre la
lógica proposicional y la teoría de tipos, llamada correspondencia de
Curry-Howard. Sin entrar en detalles, a cada proposición lógica se le puede
asignar un tipo, y a cada demostración de un enunciado un término del tipo
correspondiente al enunciado.

\todoref{HTT}

Existen distintas elecciones de reglas de transformación que considerar en
teoría de tipos, que dan lugares a distintas versiones de la teoría de tipos.
Lean implementa una una versión de la teoría de tipos dependiente conocida como
el \textit{Calculus of Constructions}.

La base de muchas teorías de tipos es el lambda cálculo, un modelo universal de
computación introducido por \textit{Alonzo Church} en los años treinta. Sin
entrar en su formalización, en el lambda cálculo se consideran dos operaciones
fundamentales para tratar con funciones, la abstracción y la evaluación.

\begin{itemize}

	\item \textbf{Abstracción}. Es el mecanismo de definición de funciones mediante
	      la introducción de parámetros. Dado un término \lstinline{x + 1 : ℕ},
	      mediante la sintaxis \lstinline{λ x : ℕ, (x + 1 : ℕ)} se convierte la
	      variable libre \lstinline{x} en una variable ligada por la abstracción, a la
	      que llamamos parámetro de la función.

	      Es importante recordar que cada término tiene que ir acompañado del tipo al
	      que pertenece. En esta expresión estamos indicando que tanto el parámetro
	      \lstinline{x} como el resultado de la función, \lstinline{x+1}, son de tipo
	      \lstinline{ℕ}. Es decir, tenemos una función que dado un número natural
	      devuelve otro número natural. Esto también puede escribirse como
	      \lstinline{(λ x, x + 1) : ℕ → ℕ}.

	      Lean además incluye notación para definir funciones que devuelven otras
	      funciones, lo cual es muy útil para tratar funciones que reciben más de un
	      parámetro (\todoref{Ver currificacion}). Las siguientes líneas de código
	      definen expresiones equivalentes
	      \begin{lstlisting}
λ a : α, λ b : β, a
λ (a : α) (b : β), a
\end{lstlisting}
	      que representan el mismo término, de tipo \lstinline{α → β → α}.

	\item \textbf{Evaluación}. Consiste en aplicar funciones, pasándoles los
	      valores de los argumentos que evaluar. Por ejemplo la expresión
	      \lstinline{(λ x : ℕ, (x + 1) : ℕ) (1 : ℕ)} indica que estamos evaluando la
	      función \lstinline{(λ x, x + 1) : ℕ → ℕ} con el parámetro \lstinline{x}
	      sustituido por el término \lstinline{1 : ℕ} (para que la sustitución pueda
	      realizarse los tipos deben coincidir). Mediante un proceso de
	      reducción se obtiene el término \lstinline{2 : ℕ}.

\end{itemize}

\todoref{Theorem proving in Lean}

Como se ve en los ejemplos, el código fuente de Lean se pueden incluir
caracteres unicode, como \lstinline{λ}, \lstinline{→} o \lstinline{ℕ}. Esta
característica del lenguaje es muy útil a la hora de escribir código lo más
cercano posible a las notaciones a las que estamos acostumbrados a usar en
matemáticas. La inclusión de estos caracteres está facilitada en el entorno de
desarrollo, escribiendo comandos que empiecen por \texttt{\textbackslash} estos
se reemplazarán por el caracter correspondiente. Por ejemplo al escribir
\texttt{\textbackslash to} este comando se reemplazará automáticamente por el
caracter \lstinline{→}, \texttt{\textbackslash lambda} por \lstinline{λ} y
\texttt{\textbackslash N} por \lstinline{ℕ}.

\todo{Incluir en algún lugar explicación sobre entorno de desarrollo (plugin vscode) y sus características (¿Apéndice?).}

Que cada término sea siempre considerado junto a su tipo no significa que sea
siempre necesario explicitar dicho tipo. Lean tiene un mecanismo llamado
\textit{inferencia de tipos} que le permite deducir automáticamente el tipo de
un término cuando no ha sido explicitado pero el contexto aporta información
suficiente.
Por ejemplo, cuando definimos la función \lstinline{λ x : ℕ, (x + 1 : ℕ)} no es
necesario incluir la segunda anotación de tipo. Dada la expresión
\lstinline{x + 1} y sabiendo por contexto que \lstinline{x : ℕ} el sistema de
inferencia de tipos deduce que la suma de dos números naturales también es un
número natural, por lo que se infiere el tipo \lstinline{ℕ}.

\section{Proposiciones en Lean}

En Lean se tiene el tipo \lstinline{Prop} para expresar las proposiciones
mediante la analogía de \textit{proposiciones como tipos} dada por la
correspondencia de Curry-Howard.

La correspondencia de Curry-Howard afirma que estas funciones de la
teoría de tipos se comportan de la misma forma que la implicación en lógica. Por
tanto en Lean utilizaremos el símbolo \lstinline{→} para referirnos tanto a
funciones como a implicaciones dentro de una proposición. Dadas dos
proposiciones \lstinline{p q : Prop} podemos construir la proposición
\lstinline{p → q : Prop}, que se interpreta como \lstinline{p} \textit{implica}
\lstinline{q}.



\newpage
\section{Formalizando la geometría de Hilbert en Lean}
\begin{itemize}
	\item Otros trabajos
	      \begin{itemize}
		      \item Descubrimiento de saltos de intuicion en Hilbert
		      \item Paper en el que se analizan las decisiones de diseño de
		            software a la hora de formalizar.
		      \item Formalización de la independencia del quinto postulado
		            utilizando los axiomas de Tarski.
	      \end{itemize}
	\item Mi trabajo. Formalizando la geometría de Hilbert.
	      \begin{itemize}

		      \item Geometría de incidencia. Comparación entre los
		            axiomas originales de Hilbert, su redacción moderna y
		            mi formalización en Lean. Introducción a conceptos
		            y funciones de Lean mediante ejemplos (clases,
		            tipos de parámetros, etc)
		      \item Otros grupos de axiomas y tratamientos.
		      \item Idea demostración de independencia del axioma de
		            las paralelas.
	      \end{itemize}
\end{itemize}

En esta sección se presentan algunos axiomas y resultados elementales de la
axiomática de Hilbert, comparando los enunciados y demostraciones expresados de
forma natural (\todo{¿Cómo expresar esto bien?}) con sus correspondientes
formalizaciones en Lean.

\subsection{Geometría de incidencia}

\todo{Explicar cómo funcionan las clases, comparar los axiomas de hilbert
	expresados en lenguaje natural con sus formalizaciones. Diferencias entre
	parámetros implícitos y explícitos.}


\setaxsection{I}
\begin{ax}\label{I1}
	Para cada par de puntos distintos $A, B$ existe una única recta que los
	contiene.
\end{ax}

\begin{ax}\label{I2}
	Cada línea contiene al menos dos puntos distintos.
\end{ax}

\begin{ax}\label{I3}
	Existen tres puntos no colineares. Es decir, existen $A$, $B$ y $C$ tales que
	$AB\neq BC$.
\end{ax}

\begin{lstlisting}
class incidence_geometry (Point Line : Type*) :=
  (lies_on : Point → Line → Prop)
  (infix ` ~ ` : 50 := lies_on)
  (I1 {A B : Point} (h : A ≠ B): ∃! l : Line, A ~ l ∧ B ~ l)
  (I2 (l : Line) : ∃ A B : Point, A ≠ B ∧ A ~ l ∧ B ~ l)
  (I3 : ∃ A B C : Point, different3 A B C ∧ ¬ ∃ l : Line,  A ~ l ∧ B ~ l ∧ C ~ l)
\end{lstlisting}

\subsection{Resultados elementales}

Uno de los primeros resultados que se pueden demostrar, utilizando sólamente los
axiomas de incidencia es el siguiente:

\begin{prop}
	Dos líneas distintas pueden tener como mucho un punto en común.
\end{prop}


Su correspondiente formalización en Lean es:


\begin{lstlisting}
lemma disctinct_lines_one_common_point 
  {Point Line : Type*} [ig : incidence_geometry Point Line] :
  ∀ l m : Line, l ≠ m → 
    (∃! A : Point, is_common_point A l m) ∨ (¬ have_common_point Point l m) := 
begin
  sorry
end
\end{lstlisting}


Se puede observar que, gracias al uso de caracteres unicode, la formalización en
Lean es muy fácil de leer y cercana a la forma de escribir matemáticas a la que
estamos acostumbrados.

\todo{¿Incidir sobre la diferencia entre parámetros explícitos e implícitos?}

Observemos que en el enunciado se están utilizando algunas definiciones que se
han declarado previamente:

\begin{lstlisting}
def is_common_point {Point Line : Type*} [incidence_geometry Point Line] 
  (A : Point) (l m : Line) := A ~ l ∧ A ~ m 

def have_common_point (Point : Type*) {Line : Type*} [incidence_geometry Point Line]
  (l m : Line) := ∃ A : Point, is_common_point A l m
\end{lstlisting}

\todo{Aquí si que sería conveniente explicar por qué algunos parámetros son
	implícitos y otros explícitos.}

La demostración, como la presenta el libro de Hartshorne (\todo{citar}), es como
sigue:
\begin{proof}
	Sean $l$ y $m$ dos líneas. Supongamos que ambas contienen los puntos $A$ y
	$B$ con $A\ne B$. Por el axioma I1, existe una única línea que pasa por $A$
	y $B$, por lo que $l$ y $m$ deben ser iguales.
\end{proof}

Esta demostración puede interpretarse como una demostración por absurdo sobre la
condición de que las dos líneas sean iguales, o como una demostración por
contraposición: si asumimos que no se cumple la conclusión (que las dos lineas
no tengan más de un punto en común), entonces tampoco se cumple la premisa (que las
dos líneas sean iguales).

Al intentar implementar esta idea en Lean nos damos cuenta de que hay bastantes
detalles que necesitamos tener en cuenta.

Esta es la formalización completa del resultado en Lean, incluyendo el enunciado
y su demostración:

\begin{lstlisting}
lemma disctinct_lines_one_common_point 
  {Point Line : Type*} [ig : incidence_geometry Point Line] :
  ∀ l m : Line, l ≠ m → 
    (∃! A : Point, is_common_point A l m) ∨ (¬ have_common_point Point l m) := 
begin
  intros l m, 
  contrapose,
  push_neg,
  rintro ⟨not_unique, hlm⟩,
  rw exists_unique at not_unique,
  push_neg at not_unique,
  cases hlm with A hA,
  rcases not_unique A hA with ⟨B, ⟨hB, hAB⟩⟩,
  rw ne_comm at hAB,
  exact unique_of_exists_unique (ig.I1 hAB) ⟨hA.left,hB.left⟩ ⟨hA.right,hB.right⟩,
end
\end{lstlisting}

\todo{Explicar qué es una demostración en Lean. Que es el estado táctico y la
	meta, qué hacen las tácticas.}

Analicemos detalladamente cada uno de los pasos:

\begin{itemize}

	\item El estado táctico inicial incluye los parámetros del lema. En este caso
	      los tipos \lstinline{Point} y \lstinline{Line} e \lstinline{ig}, la
	      instancia de la clase \lstinline{incidence_geometry}. Esta instancia
	      representa el hecho de que los tipos \lstinline{Point} y \lstinline{Line}
	      cumplen los axiomas de la geometría de incidencia. La meta se corresponde
	      con el enunciado del lema, es decir lo que queremos demostrar.

	\item \lstinline{intros l m,} La aplicación de la táctica \lstinline{intros}
	      introduce las hipótesis \lstinline{l} y \lstinline{m}. Es decir, saca el
	      cuantificador universal de la meta e introduce las variables cuantificadas
	      en el estado táctico, pasando a tener ahora dos nuevos términos
	      \lstinline{l : Line} y \lstinline{m : Line}. La nueva meta es

	      \begin{lstlisting}
m → (∃! (A : Point), 
  is_common_point A l m) ∨ ¬have_common_point Point l m
      \end{lstlisting}
	      Esto equivale a decir en lenguaje natural "sean l y m dos líneas"


	\item \lstinline{contrapose,} La táctica \lstinline{contrapose} permite realizar una
	      demostración por contraposición. Es decir, si nuestra meta es de la
	      forma \lstinline{A → B}, la reemplaza por \lstinline{¬B → ¬A}. En este
	      caso la meta resultante es
	      \begin{lstlisting}
(∃! (A : Point), is_common_point A l m) ∨ ¬have_common_point Point l m) 
  → ¬l ≠ m
      \end{lstlisting}

	\item \lstinline{push_neg, } La táctica \lstinline{push_neg} utiliza equivalencias
	      lógicas para 'empujar' las negaciones dentro de la fórmula. En este
	      caso, al no haber especificado una hipótesis concreta, se aplica sobre
	      la meta.

	      En la primera parte de la implicación se aplica una ley de De Morgan
	      para introducir la negación dentro de una disjunción, convirtiéndola en
	      una conjunción de negaciones. En la segunda, negar una desigualdad
	      equivale a una igualdad.

	      Por tanto la meta resultante es
	      \begin{lstlisting}
∃! (A : Point), is_common_point A l m) ∧ have_common_point Point l m → l = m
   \end{lstlisting}
	      Es interesante notar que \lstinline{push_neg} no consigue 'empujar' la negación todo lo que podríamos desear.

	      Esto es así porque no está reescribiendo las definiciones previas y de
	      \lstinline{∃!}. Esto lo tendremos que hacer manualmente, como se verá enseguida.

	\item \lstinline{rintro ⟨not_unique, hlm⟩,} La táctica \lstinline{rintro} funciona como
	      \lstinline{intro}, en este caso aplicada para asumir la hipótesis de la implicación
	      que queremos demostrar. La variante \lstinline{rintro} nos permite entrar en
	      definiciones recursivas, en este caso en la del operador \lstinline{∧}, y mediante
	      el uso de los paréntesis \lstinline{⟨⟩} introducir los dos lados de la conjunción
	      como hipótesis separadas. Por tanto después de aplicar esta táctica
	      obtendremos dos hipótesis adicionales:
	      \begin{lstlisting}
unique: ¬∃! (A : Point), is_common_point A l m
 have_common_point Point l m
      \end{lstlisting}
	      y la meta resultante es el segundo lado de la implicación, es decir \lstinline{⊢ l = m}.

	\item \lstinline{rw exists_unique at not_unique,}  La táctica \lstinline{rw}
	      (abreviación de \lstinline{rewrite}) nos permite reescribir ocurrencias
	      de fórmulas utilizando definiciones o lemas de la forma
	      \lstinline{A ↔ B}. Al escribir \lstinline{at} indicamos dónde queremos realizar dicha
	      reescritura, en este caso en la hipótesis \lstinline{not_unique}.

	      En este caso utilizamos la definición de \lstinline{∃!}, con lo que se
	      modifica la hipótesis
	      \begin{lstlisting}
  unique : ¬∃ (x : Point), 
  _common_point x l m ∧ ∀ (y : Point), is_common_point y l m → y = x
      \end{lstlisting}

	\item \lstinline{push_neg at not_unique,}
	      %   /- Como comentábamos antes, ahora que hemos reescrito la definición de ∃! podemos seguir "empujando" la negación en la hipótesis not_unique,
	      %      obteniendo ∀ (x : Point), is_common_point x l m → (∃ (y : Point), is_common_point y l m ∧ y ≠ x)
	      %   -/

	\item \lstinline{cases hlm with A hA,} La táctica \lstinline{cases} nos
	      permite, entre otras cosas, dada una hipótesis de existencia, obtener un
	      término del tipo cuantificado por el existe y la correspondiente
	      hipótesis particularizada para el nuevo término.

	      En nuestro caso tenemos la hipótesis \lstinline{hlm: have_common_point Point l m}
	      y la definición \\ \lstinline{have_common_point Point l m := ∃ A : Point, is_common_point A l m}.

	      Por tanto al aplicar la táctica, la hipótesis hlm se convierte en dos nuevas hipótesis
	      \begin{lstlisting}
  Point 
  is_common_point A l m
      \end{lstlisting}

	\item \lstinline{rcases not_unique A hA with ⟨B, ⟨hB, hAB⟩⟩,} En esta línea
	      están ocurriendo distintas cosas:
	      \begin{itemize}

		      \item Recordemos que en el estado táctico actual tenemos la hipótesis
		            \begin{lstlisting}
  unique: ∀ (x : Point), is_common_point x l m 
            → (∃ (y : Point), is_common_point y l m ∧ y ≠ x) 
              \end{lstlisting}

		            Primero se está construyendo el término \lstinline{not_unique A hA},
		            al que posteriormente se le aplicará la táctica {rcases}.

		            En Lean los cuantificadores universales y las implicaciones
		            pueden tratarse como funciones. Al pasar el primer argumento
		            \lstinline{A} estamos particularizando la cuantificación sobre
		            el punto \lstinline{x}, proporcionando el término
		            \lstinline{A : Point} que tenemos entre nuestras hipótesis. Por
		            tanto el término \lstinline{not_unique A} es igual a
		            \begin{lstlisting}
  ommon_point A l m → (∃ (y : Point), is_common_point y l m ∧ y ≠ A)
              \end{lstlisting}
		            Ahora podemos observar que tenemos entre nuestras hipótesis la
		            condición de esta implicación, \lstinline{hA: is_common_point A l m}
		            Al pasar este término como segundo argumento obtenemos la
		            conclusión de la implicación, y por tanto el término
		            \lstinline{not_unique A hA} es igual a
		            \begin{lstlisting}
   : Point), is_common_point y l m ∧ y ≠ x
              \end{lstlisting}

		      \item La aplicación de la táctica \lstinline{rcases} nos permite, como
		            anteriormente, obtener un término concreto del cuantificador
		            existencial y además profundizar en la definición recursiva del
		            \lstinline{∧}, generando así dos hipótesis separadas. Obtenemos por tanto
		            las nuevas hipótesis
		            \begin{lstlisting}
  oint 
  is_common_point B l m 
   B ≠ A
              \end{lstlisting}
	      \end{itemize}

	\item \lstinline{rw ne_comm at hAB,} Para tener la hipótesis \lstinline{hAB: B ≠ A} en
	      el mismo orden que el utilizado en los axiomas y poder utilizarlos
	      correctamente, reescribimos la hipótesis \lstinline{hAB} utilizando la propiedad
	      conmutativa de la desigualdad, obteniendo así la hipóteis \lstinline{hAB: A ≠ B}.

	\item \lstinline{exact unique_of_exists_unique (ig.I1 hAB) ⟨hA.left,hB.left⟩ ⟨hA.right,hB.right⟩,}

	      La táctica \lstinline{exact} se utiliza para concluir la demostración proporcionando
	      un término igual a la meta. Recordemos que la meta actual es \lstinline{⊢ l = m}.

	      Analicemos entonces el término que estamos proporcionando a la táctica.

	      El lema \lstinline{unique_of_exists_unique}, definido en la librería
	      estándar de Lean, sirve para extrer la parte de unicidad del
	      cuantificador \lstinline{∃!}. Dadas una fórmula de la forma
	      \lstinline{∃! x, px} y dos fórmulas \lstinline{p a} y \lstinline{p b}
	      , devuelve la fórmula que aserta la igualdad entre los términos que
	      cumplen la propiedad \lstinline{p}: \lstinline{a = b}.

	      Como primer argumento le estamos pasando el primer axioma de incidencia,
	      particularizado con la hipóteis \lstinline{hAB : A ≠ B}. Es decir
	      \lstinline{ig.I1 hAB} es igual a \lstinline{∃! l : Line, A ~ l ∧ B ~ l}.

	      Ahora queremos pasar en los otros dos argumentos términos
	      \lstinline{A ~ l ∧ B ~ l} y \lstinline{A ~ m ∧ B ~ m}, para obtener la
	      igualdad \lstinline{l = m}. Para esto tenemos que recombinar las
	      hipótesis \lstinline{hA} y \lstinline{hB}.

	      \lstinline{hA.left} es igual a \lstinline{A ~ l} y \lstinline{hB.left} a
	      \lstinline{B ~ l}, y mediante los paréntesis \lstinline{⟨⟩} combinamos
	      estos términos en la conjunción \lstinline{⟨hA.left,hB.left⟩},
	      obteniendo \lstinline{A ~ l ∧ B ~ l}.

	      El uso de los paréntesis nos permite construir una conjunción sin tener
	      que especificar esplícitamente que queremos construir una conjunción,
	      pero el sistema de tipos de Lean permite inferir que el término esperado
	      es una conjunción.

	      Análogamente para el segundo argumento.
\end{itemize}














































































































