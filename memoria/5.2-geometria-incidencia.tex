\subsection{Geometría de incidencia}

El primer grupo de axiomas establece propiedades de la relación de
\textit{incidencia}, una relación binaria entre \textit{puntos} y
\textit{líneas}. Dado un punto $A$ y una recta $l$ escribiremos $A\sim l$ para
denotar que $A$ y $l$ están relacionados mediante la relación de incidencia.
Los tres \textit{axiomas de incidencia} son los siguientes:

\setaxsection{I}
\begin{ax}\label{ax:I1}
	Para cada par de puntos distintos $A$ y $B$ existe una única recta que los
	contiene.
\end{ax}

\begin{ax}\label{ax:I2}
	Cada línea contiene al menos dos puntos distintos.
\end{ax}

\begin{ax}\label{ax:I3}
	Existen tres puntos no colineares. Es decir, existen $A$, $B$ y $C$ tales que
	$AB\neq BC$.
\end{ax}

Para formalizar estos axiomas en Lean podríamos utilizar el comando
\lstinline{constant} o \lstinline{axiom}, pero existen otras construcciones que
permiten explicitar mejor y tener más control sobre qué axiomas se están
usando en cada momento. En lugar de enunciar un axioma y a partir de entonces
darlo siempre por válido, definiremos un objeto (un nuevo tipo) en el que
agruparemos nociones primitivas y axiomas sobre estas.

Se procederá de forma análoga a la definición usual de un \textit{grupo}, en el
se consideran un conjunto (en \textit{Lean} trabajaremos con tipos) con una
operación, un elemento distinguido y unos axiomas. Para definir la
\textit{geometría de incidencia} se toman dos tipos (uno para los puntos y otro
para las líneas), una relación entre estos tipos (la incidencia) y los axiomas.

Para hacer esto \textit{Lean} consta de dos construcciones muy similares, las
\textit{estructuras} y las \textit{clases}, mediante las cuales se pueden
agrupar tipos y proposiciones sobre estos tipos.
\todo{Explicar brevemente diferencia entre estructuras y clases.}
Esta es la definición de clase mediante la que
hemos digitalizado las nociones y conceptos de la \textit{geometría de incidencia}:

\lstleanfull{incidence_geometry/basic.lean}{17}{22}

Como se puede intuir leyendo el código, los tipos \lstinline{Point} y
\lstinline{Line} son parámetros de la clase. Las siguientes líneas explicitan
términos que tienen que existir y tener el tipo especificado después de los dos
puntos.

La relación de incidencia se ha formalizado como una función que dados un punto
y una línea devuelve la proposición que determina si el punto está en la línea.
En la línea 19 se introduce la notación mencionada anteriormente, mediante el
comando \lstinline{infix}. En los axiomas, siguiendo el estilo de la libería
\textit{mathlib}, se ha evitado el uso de cuantificadores universales, y en su
lugar se han incluido los términos correspondientes como parámetros, lo que es
equivalente en teoría de tipos pero más cómodo de leer.

Es interesante observar lo cercano que es el código en \textit{Lean} a la forma
en la que escribiríamos los axiomas utilizando los símbolos usuales de la
lógica. No es necesario tener conocimientos de \textit{Lean} para entender la
mayoría de los enunciados (no se da el mismo caso con las demostraciones).

\todo{Explicar cómo se usan las clases. Parámetros con corchetes e instancias.}

\subsubsection{Definiciones}

Las siguientes definiciones son útiles para tratar con puntos y líneas y
continuar el desarrollo de la teoría.

En las demostraciones es útil tenér una forma de, dados dos puntos distintos,
construir el término de la línea que pasa por ellos, aprovechando el
axioma~\hyperref[ax:I1]{I1}.

\lstleanfull{incidence_geometry/basic.lean}{30}{40}

El tipo de esta definición (línea 33) es un \textit{tipo dependiente}: al tipo
\lstinline{Line} se le asocia la propiedad de que los puntos pertenezcan al
término correspondiente. En el código fuente completo hemos desarrollado también
una versión de esta función, \lstinline{line_unique}, que también devuelve la
propiedad de unicidad dada por el axioma~\hyperref[ax:I2]{I2}.

\begin{defin*}[Colinearidad]
	Decimos que tres puntos distintos son \textbf{colineares} si existe una
	línea que los contiene (todos los puntos inciden en la línea).
\end{defin*}

\lstleanfull{incidence_geometry/basic.lean}{60}{61}

En esta definición el parámetro del tipo \lstinline{Point : Type*} es implícito,
puesto que se puede inferir a partir de los términos \lstinline{A B C : Point}.
\lstinline{Line : Type*} sin embargo tiene que ser explícito ya que los demás
parámetros no proporcionan información suficiente para inferirlo
automáticamente.

\begin{defin*}[Puntos comunes]
	Decimos que un punto es \textbf{común} a dos líneas si está en ambas líneas.
	Si dadas dos líneas existe un punto común, decimos que las líneas
	\textbf{tienen} un punto en común.
\end{defin*}

\lstleanfull{incidence_geometry/basic.lean}{173}{176}

En este caso los parámetros \lstinline{Point Line : Type*} son ambos implícitos
porque los argumentos \lstinline{A : Point} y \lstinline{l m : Line}
proporcionan la información necesaria para la inferencia automática.

\lstleanfull{incidence_geometry/basic.lean}{179}{182}

\subsubsection{Resultados}

Uno de los primeros resultados que se pueden demostrar, utilizando sólamente los
axiomas de incidencia es el siguiente:

\begin{prop}
	Dos líneas distintas pueden tener como mucho un punto en común.
\end{prop}

\begin{proof}
	Sean $l$ y $m$ dos líneas. Supongamos que ambas contienen los puntos $A$ y
	$B$ con $A\ne B$. Por el axioma I1, existe una única línea que pasa por $A$
	y $B$, por lo que $l$ y $m$ deben ser iguales.
\end{proof}

Esta demostración, que sigue la presentación del libro
de~\textit{Hartshorne}~\cite{hartshorneGeometryEuclid2000}, puede interpretarse
como una demostración por reducción al absurdo sobre la condición de que las dos
líneas sean iguales, o como una demostración por contraposición: si asumimos que
no se cumple la conclusión (que las dos lineas no tengan más de un punto en
común), entonces tampoco se cumple la premisa (que las dos líneas sean iguales).

Al implementar estas ideas en Lean nos damos cuenta de que hay bastantes
detalles que necesitamos tener en cuenta.

\lstleanfull{incidence_geometry/propositions.lean}{21}{37}

Analicemos la demostración línea por línea:
\begin{enumerate}[label=L.\arabic*, topsep=0mm]
	\setcounter{enumi}{25}

	\item El estado táctico inicial incluye los parámetros del lema. En este caso
	      los tipos \lstinline{Point} y \lstinline{Line} e \lstinline{ig}, la
	      instancia de la clase \lstinline{incidence_geometry}. Esta instancia
	      representa el hecho de que los tipos \lstinline{Point} y \lstinline{Line}
	      cumplen los axiomas de la geometría de incidencia.

	      La meta se corresponde con el enunciado del lema, es decir lo que queremos
	      demostrar.


	\item \lstinline{intros l m,} La aplicación de la táctica \lstinline{intros}
	      introduce las hipótesis \lstinline{l} y \lstinline{m}. Es decir, saca el
	      cuantificador universal de la meta e introduce las variables cuantificadas
	      en el estado táctico, pasando a tener ahora dos nuevos términos
	      \lstinline{l : Line} y \lstinline{m : Line}. La nueva meta es
	      \begin{lstlisting}
l ≠ m → (∃! (A : Point), is_common_point A l m) ∨ ¬have_common_point Point l m
\end{lstlisting}
	      Esto equivale a decir en lenguaje natural "sean l y m dos líneas"

	\item \lstinline{contrapose,} La táctica \lstinline{contrapose} permite
	      realizar una demostración por contraposición. Es decir, si nuestra meta es
	      de la forma \lstinline{A → B}, la reemplaza por \lstinline{¬B → ¬A}. En
	      este caso la meta resultante es
	      \begin{lstlisting}
⊢ ¬((∃! (A : Point), is_common_point A l m) ∨ ¬have_common_point Point l m) 
  → ¬l ≠ m
\end{lstlisting}

	\item \lstinline{push_neg, } La táctica \lstinline{push_neg} utiliza
	      equivalencias lógicas para \guillemotleft empujar\guillemotright las negaciones dentro de la fórmula.
	      En este caso, al no haber especificado una hipótesis concreta, se aplica
	      sobre la meta.

	      En la primera parte de la implicación se aplica una ley de De Morgan para
	      introducir la negación dentro de una disjunción, convirtiéndola en una
	      conjunción de negaciones. En la segunda, negar una desigualdad equivale a
	      una igualdad. Por tanto la meta resultante es
	      \begin{lstlisting}
⊢ (¬∃! (A : Point), is_common_point A l m) 
  ∧ have_common_point Point l m → l = m
\end{lstlisting}

	      Es interesante notar que \lstinline{push_neg} no consigue 'empujar' la negación todo lo que podríamos desear.

	      Esto es así porque no está reescribiendo las definiciones previas y de
	      \lstinline{∃!}. Esto lo tendremos que hacer manualmente, como se verá
	      enseguida.

	\item \lstinline{rintro ⟨not_unique, hlm⟩,} La táctica \lstinline{rintro}
	      funciona como \lstinline{intro}, en este caso aplicada para asumir la
	      hipótesis de la implicación que queremos demostrar. La variante
	      \lstinline{rintro} nos permite entrar en definiciones recursivas, en este
	      caso en la del operador \lstinline{∧}, y mediante el uso de los paréntesis
	      \lstinline{⟨⟩} introducir los dos lados de la conjunción como hipótesis
	      separadas. Por tanto después de aplicar esta táctica obtendremos dos
	      hipótesis adicionales:
	      \begin{lstlisting}
not_unique: ¬∃! (A : Point), is_common_point A l m
hlm: have_common_point Point l m
\end{lstlisting}
	      y la meta resultante es el segundo lado de la implicación, es decir
	      \lstinline{⊢ l = m}.

	\item \lstinline{rw exists_unique at not_unique,}  La táctica \lstinline{rw}
	      (abreviación de \lstinline{rewrite}) nos permite reescribir ocurrencias de
	      fórmulas utilizando definiciones o lemas de la forma \lstinline{A ↔ B}. Al
	      escribir \lstinline{at} indicamos dónde queremos realizar dicha
	      reescritura, en este caso en la hipótesis \lstinline{not_unique}.

	      En este caso utilizamos la definición de \lstinline{∃!}, con lo que se modifica la hipótesis
	      \begin{lstlisting}
not_unique : ¬∃ (x : Point), 
is_common_point x l m ∧ ∀ (y : Point), is_common_point y l m → y = x
\end{lstlisting}

	\item \lstinline{push_neg at not_unique,}
	      \todo{revisar}
	      %   /- Como comentábamos antes, ahora que hemos reescrito la definición de ∃! podemos seguir "empujando" la negación en la hipótesis not_unique,
	      %      obteniendo ∀ (x : Point), is_common_point x l m → (∃ (y : Point), is_common_point y l m ∧ y ≠ x)
	      %   -/

	\item \lstinline{cases hlm with A hA,} La táctica \lstinline{cases} nos
	      permite, entre otras cosas, dada una hipótesis de existencia, obtener un
	      término del tipo cuantificado por el existe y la correspondiente hipótesis
	      particularizada para el nuevo término.

	      En nuestro caso tenemos la hipótesis \lstinline{hlm: have_common_point Point l m} y la definición
	      \lstinline{have_common_point Point l m := ∃ A : Point, is_common_point A l m}.

	      Por tanto al aplicar la táctica, la hipótesis hlm se convierte en dos
	      nuevas hipótesis
	      \begin{lstlisting}
A : Point 
hA: is_common_point A l m
\end{lstlisting}

	\item \lstinline{rcases not_unique A hA with ⟨B, ⟨hB, hAB⟩⟩,} En esta línea
	      están ocurriendo distintas cosas:
	      \begin{itemize}
		      \item Recordemos que en el estado táctico actual tenemos la hipótesis
		            \begin{lstlisting}
not_unique: ∀ (x : Point), is_common_point x l m 
→ (∃ (y : Point), is_common_point y l m ∧ y ≠ x) 
\end{lstlisting}

		            Primero se está construyendo el término \lstinline{not_unique A hA},
		            al que posteriormente se le aplicará la táctica {rcases}.

		            En Lean los cuantificadores universales y las implicaciones pueden
		            tratarse como funciones. Al pasar el primer argumento \lstinline{A}
		            estamos particularizando la cuantificación sobre el punto
		            \lstinline{x}, proporcionando el término \lstinline{A : Point} que
		            tenemos entre nuestras hipótesis. Por tanto el término
		            \lstinline{not_unique A} es igual a
		            \begin{lstlisting}
is_common_point A l m → (∃ (y : Point), is_common_point y l m ∧ y ≠ A)
\end{lstlisting}

		            Ahora podemos observar que tenemos entre nuestras hipótesis la
		            condición de esta implicación, \lstinline{hA: is_common_point A l m}
		            Al pasar este término como segundo argumento obtenemos la conclusión
		            de la implicación, y por tanto el término
		            \lstinline{not_unique A hA} es igual a
		            \begin{lstlisting}
∃ (y : Point), is_common_point y l m ∧ y ≠ x
\end{lstlisting}

		      \item La aplicación de la táctica \lstinline{rcases} nos permite, como
		            anteriormente, obtener un término concreto del cuantificador
		            existencial y además profundizar en la definición recursiva del
		            \lstinline{∧}, generando así dos hipótesis separadas. Obtenemos por
		            tanto las nuevas hipótesis
		            \begin{lstlisting}
B: Point 
hB: is_common_point B l m 
hAB: B ≠ A
\end{lstlisting}
	      \end{itemize}

	\item \lstinline{rw ne_comm at hAB,} Para tener la hipótesis
	      \lstinline{hAB: B ≠ A} en el mismo orden que el utilizado en los axiomas y
	      poder utilizarlos correctamente, reescribimos la hipótesis \lstinline{hAB}
	      utilizando la propiedad conmutativa de la desigualdad, obteniendo así la
	      hipóteis \lstinline{hAB: A ≠ B}.

	\item \lstinline{exact unique_of_exists_unique (ig.I1 hAB) ⟨hA.left,hB.left⟩ ⟨hA.right,hB.right⟩,}

	      La táctica \lstinline{exact} se utiliza para concluir la demostración
	      proporcionando un término igual a la meta. Recordemos que la meta actual
	      es \lstinline{⊢ l = m}.

	      Analicemos entonces el término que estamos proporcionando a la táctica.

	      El lema \lstinline{unique_of_exists_unique}, definido en la librería
	      estándar de Lean, sirve para extrer la parte de unicidad del cuantificador
	      \lstinline{∃!}. Dadas una fórmula de la forma \lstinline{∃! x, px} y dos
	      fórmulas \lstinline{p a} y \lstinline{p b} , devuelve la fórmula que
	      aserta la igualdad entre los términos que cumplen la propiedad
	      \lstinline{p}: \lstinline{a = b}.

	      Como primer argumento le estamos pasando el primer axioma de incidencia,
	      particularizado con la hipóteis \lstinline{hAB : A ≠ B}. Es decir
	      \lstinline{ig.I1 hAB} es igual a \lstinline{∃! l : Line, A ~ l ∧ B ~ l}.

	      Ahora queremos pasar en los otros dos argumentos términos
	      \lstinline{A ~ l ∧ B ~ l} y \lstinline{A ~ m ∧ B ~ m}, para obtener la
	      igualdad \lstinline{l = m}. Para esto tenemos que recombinar las hipótesis
	      \lstinline{hA} y \lstinline{hB}.

	      \lstinline{hA.left} es igual a \lstinline{A ~ l} y \lstinline{hB.left} a
	      \lstinline{B ~ l}, y mediante los paréntesis \lstinline{⟨⟩} combinamos
	      estos términos en la conjunción \lstinline{⟨hA.left,hB.left⟩}, obteniendo
	      \lstinline{A ~ l ∧ B ~ l}.

	      El uso de los paréntesis nos permite construir una conjunción sin tener
	      que especificar esplícitamente que queremos construir una conjunción, pero
	      el sistema de tipos de Lean permite inferir que el término esperado es una
	      conjunción.

	      Análogamente para el segundo argumento.
\end{enumerate}

\todo{Mencionar que el código del modo táctico no se parece tanto a la forma
	usual de escribir matemáticas, pero la experiencia dada por el entorno sí que se
	acerca más.}

De las siguientes proposiciones incluiremos sólo los enunciados. El desarrollo
de las demostraciones se encuentra en el repositorio de código.


\begin{prop}
	Tres puntos no colineares determinan tres líneas distintas.
\end{prop}

\lstleanfull{incidence_geometry/propositions.lean}{40}{51}


\begin{prop}
	Existen tres líneas distintas que no pasan por un punto común, es decir
	tales que no existe un punto que está en todas ellas.
\end{prop}

\lstleanfull{incidence_geometry/propositions.lean}{76}{84}

\begin{prop}
	Para cada línea existe un punto que no está ella.
\end{prop}

\lstleanfull{incidence_geometry/propositions.lean}{107}{110}

\begin{prop}
	Para cada punto existe una línea que no pasa por él.
\end{prop}

\lstleanfull{incidence_geometry/propositions.lean}{124}{127}







